# Base class
class Animal:
    def speak(self):
        return "Animal makes a sound"
# Derived class
class Dog(Animal):
    def speak(self):
        return "Woof!"

# Create an instance of the derived class
my_dog = Dog()

# Call the method from the derived class
print(my_dog.speak())  # Output: Woof!
================================================================================================================================
#Multiple inheritence
# Base class 1
class Person:
    def __init__(self, name):
        self.name = name
    def greet(self):
        return f"Hello, my name is {self.name}."
# Base class 2
class Employee:
    def __init__(self, employee_id):
        self.employee_id = employee_id
    def get_id(self):
        return f"My employee ID is {self.employee_id}."
# Derived class inheriting from both Person and Employee
class Manager(Person, Employee):
    def __init__(self, name, employee_id, department):
        Person.__init__(self, name)  # Initialize Person part
        Employee.__init__(self, employee_id)  # Initialize Employee part
        self.department = department
    def show_details(self):
        return f"{self.greet()} {self.get_id()} I manage the {self.department} department."

# Create an instance of the derived class
manager = Manager("Alice", "E12345", "Sales")

# Call methods from base classes and derived class
print(manager.greet())         # Output: Hello, my name is Alice.
print(manager.get_id())        # Output: My employee ID is E12345.
print(manager.show_details())  # Output: Hello, my name is Alice. My employee ID is E12345. I manage the Sales department.
=================================================================================================================================
#Multilevel Inheritence

# Base class
class Animal:
    def __init__(self, species):
        self.species = species
    def eat(self):
        return f"{self.species} is eating."

# Derived class from Animal
class Mammal(Animal):
    def __init__(self, species, fur_color):
        super().__init__(species)  # Initialize the base class (Animal)
        self.fur_color = fur_color
    def breathe(self):
        return f"{self.species} breathes air."

# Further derived class from Mammal
class Dog(Mammal):
    def __init__(self, species, fur_color, name):
        super().__init__(species, fur_color)  # Initialize the base class (Mammal)
        self.name = name
    def bark(self):
        return f"{self.name} says Woof!"

# Create an instance of the Dog class
my_dog = Dog("Dog", "Brown", "Buddy")

# Call methods from all levels of the inheritance chain
print(my_dog.eat())        # Output: Dog is eating.
print(my_dog.breathe())    # Output: Dog breathes air.
print(my_dog.bark())       # Output: Buddy says Woof!

===============================================================================================================================
#Heirarchical Inheritence

# Base class
class Animal:
    def __init__(self, species):
        self.species = species
    def speak(self):
        return f"{self.species} makes a sound."

# Derived class 1
class Dog(Animal):
    def __init__(self, name):
        super().__init__("Dog")  # Initialize the base class with species
        self.name = name
    def bark(self):
        return f"{self.name} says Woof!"

# Derived class 2
class Cat(Animal):
    def __init__(self, name):
        super().__init__("Cat")  # Initialize the base class with species
        self.name = name
    def meow(self):
        return f"{self.name} says Meow!"
# Creating instances of the derived classes
dog = Dog("Buddy")
cat = Cat("Whiskers")
# Calling methods from base class and derived classes
print(dog.speak())  # Output: Dog makes a sound.
print(dog.bark())   # Output: Buddy says Woof!
print(cat.speak())  # Output: Cat makes a sound.
print(cat.meow())   # Output: Whiskers says Meow!
================================================================================================================================
#Public access modifier
class MyClass:
    def __init__(self, value):
        self.value = value  # Public attribute
    def show_value(self):  # Public method
        print(self.value)
# Usage
obj = MyClass(10)
obj.show_value()  # Accessing public method
print(obj.value)  # Accessing public attribute

Output:
10
10

===================================================================================================================================
#private access modifier
class MyClass:
    def __init__(self, value):
        self.__value = value  # Private attribute
    def __show_value(self):  # Private method
        print(self.__value)
    def public_method(self):  # Public method
        self.__show_value()  # Accessing private method within the class

# Usage
obj = MyClass(10)
# obj.__show_value()  # This would raise an AttributeError
# print(obj.__value)  # This would raise an AttributeError
obj.public_method()  # Accesses private method through a public method

Output:
10
================================================================================================================================
#Protected access modifier
lass BaseClass:
    def __init__(self, value):
        self._value = value  # Protected attribute
    def _show_value(self):  # Protected method
        print(self._value)

class SubClass(BaseClass):
    def display(self):
        self._show_value()  # Accessing protected method from the subclass

# Usage
obj = SubClass(10)
obj.display()  # Accessing protected method via public method in subclass
print(obj._value)  # Accessing protected attribute directly (not recommended)

Output:
10
10

======================================================================================================================================
#Polymorphism in Python Example
class Shape:
    def area(self):
        raise NotImplementedError("Subclasses should implement this!")
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    def area(self):
        return self.width * self.height
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    def area(self):
        import math
        return math.pi * self.radius ** 2
def print_area(shape):
    print(f"The area is: {shape.area()}")

# Usage
rectangle = Rectangle(5, 10)
circle = Circle(3)
print_area(rectangle)  # The area is: 50
print_area(circle)     # The area is: 28.274333882308138

Output:
The area is: 50
The area is: 28.274333882308138
======================================================================================================================================
#Example:Polymorphiem with class methods
class Dog:
    def speak(self):
        print("Woof!")
class Cat:
    def speak(self):
        print("Meow!")
class Bird:
    def speak(self):
        print("Chirp!")

# Tuple of objects
animals = (Dog(), Cat(), Bird())

# Call speak method on each object
for animal in animals:
    animal.speak()

Output:
Woof!
Meow!
Chirp!
=======================================================================================================================================
#Polymorphisum with inheritence
class Animal:
    def make_sound(self):
        print("Some generic sound")
class Dog(Animal):
    def make_sound(self):
        print("Woof!")
class Cat(Animal):
    def make_sound(self):
        print("Meow!")
# Create instances
animals = [Dog(), Cat()]
# Call make_sound method on each object
for animal in animals:
    animal.make_sound()

Output:
Woof!
Meow!
===============================================================================================================================================
#Polymorphisum with functions and objects
def process_object(obj):
    obj.action()
class Printer:
    def action(self):
        print("Printing...")
class Scanner:
    def action(self):
        print("Scanning...")

# Create instances
printer = Printer()
scanner = Scanner()

# Use the same function with different objects
process_object(printer)  # Printing...
process_object(scanner)  # Scanning...

Output:
Printing...
Scanning...
=========================================================================================================================================================
#Python Constructor Example
class Dog:
    def __init__(self, name, breed):
        self.name = name
        self.breed = breed

# Creating an instance of the Dog class
my_dog = Dog("Buddy", "Golden Retriever")

# Accessing attributes
print(my_dog.name)  # Output: Buddy
print(my_dog.breed)  # Output: Golden Retriever

Output:
Buddy
Golden Retriever
=============================================================================================================================================================
class Car:
    def __init__(self, make, model, year):
        self.make = make
        self.model = model
        self.year = year
    def display_info(self):
        print(f"{self.year} {self.make} {self.model}")

# Create an instance of the Car class
my_car = Car("Toyota", "Corolla", 2020)

# Display the car's information
my_car.display_info()

Output:
2020 Toyota Corolla

===================================================================================================================================================================
#Parameterized Constructor in Python Example 
class Person:
    def __init__(self, name, age, city):
        self.name = name
        self.age = age
        self.city = city
    def introduce(self):
        print(f"Hello, my name is {self.name}. I'm {self.age} years old and I live in {self.city}.")

# Creating instances of the Person class with Indian names and cities
person1 = Person("Amit", 28, "Mumbai")
person2 = Person("Priya", 24, "Bengaluru")

# Introducing the persons
person1.introduce()  # Output: Hello, my name is Amit. I'm 28 years old and I live in Mumbai.
person2.introduce()  # Output: Hello, my name is Priya. I'm 24 years old and I live in Bengaluru.

Output:
Hello, my name is Amit. I'm 28 years old and I live in Mumbai.
Hello, my name is Priya. I'm 24 years old and I live in Bengaluru.
============================================================================================================================================================================
#Non parametarized constructor
class Person:
    def __init__(self):
        self.name = "John Doe"
        self.age = 30
    def display_info(self):
        print(f"Name: {self.name}, Age: {self.age}")

# Create an instance of the Person class using the non-parameterized constructor
person = Person()

# Display the person's information
person.display_info()

Output:
Name: John Doe, Age: 30
=====================================================================================================================================================================================
#Mutiple constructors in single python class.
class Rectangle:
    def __init__(self, width=0, height=0):
        if width and height:
            self.width = width
            self.height = height
        elif width:  # Single argument used as a square's side
            self.width = width
            self.height = width
        else:  # No arguments
            self.width = 0
            self.height = 0
    def area(self):
        return self.width * self.height
    def display_info(self):
        print(f"Width: {self.width}, Height: {self.height}, Area: {self.area()}")

# Create instances using different "constructors"
rect1 = Rectangle(10, 20)  # Two arguments
rect2 = Rectangle(10)      # One argument (treated as square)
rect3 = Rectangle()        # No arguments

# Display the rectangles' information
rect1.display_info()  # Width: 10, Height: 20, Area: 200
rect2.display_info()  # Width: 10, Height: 10, Area: 100
rect3.display_info()  # Width: 0, Height: 0, Area: 0

Output:
Width: 10, Height: 20, Area: 200
Width: 10, Height: 10, Area: 100
Width: 0, Height: 0, Area: 0
===============================================================================================================================================================================================
#Method Overriding in Python Example
class Animal:
    def sound(self):
        return "Some generic animal sound"
class Dog(Animal):
    def sound(self):
        return "Bark"
class Cat(Animal):
    def sound(self):
        return "Meow"

# Creating objects of each class
generic_animal = Animal()
dog = Dog()
cat = Cat()

# Calling the sound method on each object
print(generic_animal.sound())  # Output: Some generic animal sound
print(dog.sound())             # Output: Bark
print(cat.sound())             # Output: Meow

Output:
Some generic animal sound
Bark
Meow
===============================================================================================================================================================================================
#Method resolution order
lass A:
    def who_am_i(self):
        return "I am A"
class B(A):
    def who_am_i(self):
        return "I am B"
class C(A):
    def who_am_i(self):
        return "I am C"
class D(B, C):
    pass

# Creating an object of class D
d = D()

# Method resolution order
print(d.who_am_i())  # Output: I am B

# Display the Method Resolution Order
print(D.mro())

Output:
I am B
[<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]

====================================================================================================================================================================================================
#Method overriding with multiple and multilevel inheritence
class B:
    def show(self):
        return "Show method from class B"
class C:
    def show(self):
        return "Show method from class C"
class D(B, C):
    def show(self):
        return "Show method from class D"

# Creating an object of class D
d = D()

# Calling the show method on the object of class D
print(d.show())  # Output: Show method from class D

# Displaying the MRO to see the order of inheritance

Output:
Show method from class D
[<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class 'object'>]
=============================================================================================================================================================================================================

#Overriding in multilevel inheritence

class Parent:
    def greet(self):
        return "Hello from Parent"

class Child(Parent):
    def greet(self):
        parent_message = Parent.greet(self)
        return f"{parent_message} and Hello from Child"

# Creating an object of the Child class
c = Child()

# Calling the greet method on the Child object
print(c.greet())  # Output: Hello from Parent and Hello from Child

Output:
Hello from Parent and Hello from Child

=====================================================================================================================================================================================================================
#Super()
class Parent:
    def greet(self):
        return "Hello from Parent"

class Child(Parent):
    def greet(self):
        parent_message = super().greet()
        return f"{parent_message} and Hello from Child"

# Creating an object of the Child class
c = Child()

# Calling the greet method on the Child object
print(c.greet())

 Output:
Hello from Parent and Hello from Child
=============================================================================================================================================================================================================================
#Basic data absraction
from abc import ABC, abstractmethod
class Animal(ABC):
    @abstractmethod
    def sound(self):
        pass

class Dog(Animal):
    def sound(self):
        return "Bark"

# Creating an object of the Dog class
dog = Dog()
print(dog.sound())  # Output: Bark

Output:
Bark
==================================================================================================================================================================================================================================
from abc import ABC, abstractmethod
class Car(ABC):
    @abstractmethod
    def start_engine(self):
        pass
    @abstractmethod
    def stop_engine(self):
        pass
class Kia(Car):
    def start_engine(self):
        return "Kia engine started"
    def stop_engine(self):
        return "Kia engine stopped"
class Honda(Car):
    def start_engine(self):
        return "Honda engine started"
    def stop_engine(self):
        return "Honda engine stopped"

# Creating objects of the derived classes
kia = Kia()
honda = Honda()

# Calling the methods on the objects
print(kia.start_engine())  # Output: Kia engine started
print(kia.stop_engine())   # Output: Kia engine stopped
print(honda.start_engine())  # Output: Honda engine started
print(honda.stop_engine())   # Output: Honda engine stopped

Output:
Kia engine started
Kia engine stopped
Honda engine started
Honda engine stopped
===================================================================================================================================================================================
#Concrete method in abstract base class
from abc import ABC, abstractmethod
class MyABC(ABC):
    @abstractmethod
    def abstract_method1(self):
        """Method that must be implemented in subclass."""
        pass
    @abstractmethod
    def abstract_method2(self):
        """Another method that must be implemented in subclass."""
        pass
class ConcreteClass(MyABC):
    def abstract_method1(self):
        return "Implementation of abstract_method1"
    def abstract_method2(self):
        return "Implementation of abstract_method2"

# Creating an object of ConcreteClass
concrete = ConcreteClass()

# Calling the implemented methods
print(concrete.abstract_method1())  # Output: Implementation of abstract_method1
print(concrete.abstract_method2())  # Output: Implementation of abstract_method2

Output:
Implementation of abstract_method1
Implementation of abstract_method2
=====================================================================================================================================================================================
create an abstract base class and abstract method?
Example 
from abc import ABC, abstractmethod
class Shape(ABC):
    @abstractmethod
    def area(self):
        pass
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    def area(self):
        return 3.14 * self.radius ** 2

# Creating an object of Circle
circle = Circle(5)
print(circle.area())  # Output: 78.5

Output:
78.5
=======================================================================================================================================================================================

# A list of numbers
numbers = [1, 2, 3, 4, 5]

# Create an iterator object
iterator = iter(numbers)

# Iterate through the iterator using a loop
for number in iterator:
    print(number)
===========================================================================================================================================================================================
# An iterable class (it defines __iter__() method)
class IterableExample:
    def __init__(self, data):
        self.data = data
        self.index = 0

    def __iter__(self):
        return self  # The iterable itself is also an iterator

    def __next__(self):
        if self.index < len(self.data):
            value = self.data[self.index]
            self.index += 1
            return value
        else:
            raise StopIteration

# Creating an iterable object
iterable_obj = IterableExample([10, 20, 30])

# Using the iterable object as an iterator
for item in iterable_obj:
    print(item)

# Creating another iterable object
another_iterable = [1, 2, 3]

# Using iter() to create an iterator from the iterable
iterator = iter(another_iterable)

# Using the iterator
print(next(iterator))  # Output: 1
print(next(iterator))  # Output: 2
print(next(iterator))  # Output: 3
================================================================================================================================================
# A built-in iterable (list)
numbers = [1, 2, 3, 4, 5]

# Convert the list into an iterator
iterator = iter(numbers)

# Iterate over the iterator
print(next(iterator))  # Output: 1
print(next(iterator))  # Output: 2
print(next(iterator))  # Output: 3
print(next(iterator))  # Output: 4
print(next(iterator))  # Output: 5
==========================================================================================================================================================
#Python infinite loop
import itertools
# Create an infinite iterator using itertools.count
infinite_counter = itertools.count(start=1, step=1)

# Take a few elements from the infinite iterator
for _ in range(5):
    print(next(infinite_counter))
================================================================================================================================================================
#Python Generator Example 
def simple_generator():
    yield 1
    yield 2
    yield 3

# Create a generator object
gen = simple_generator()

# Iterate through the generator
for value in gen:
    print(value)

Output:
1
2
3
==========================================================================================================================================================================
def count_up_to(max):
    count = 1
    while count <= max:
        yield count
        count += 1

# Create a generator object
counter = count_up_to(3)

# Use the generator with the next() method
print(next(counter))  # Output: 1
print(next(counter))  # Output: 2
print(next(counter))  # Output: 3

# Uncommenting the following line will raise StopIteration because the generator is exhausted
# print(next(counter))  # Raises StopIteration

# Alternatively, use the generator in a for loop
for number in count_up_to(3):
    print(number)

Output:
1
2
3
1
2
3
==========================================================================================================================================================================
# Generator expression to produce squares of numbers from 1 to 5
squares = (x**2 for x in range(1, 6))

# Iterate through the generator expression
for square in squares:
    print(square)

Output:
1
4
9
16
25
=========================================================================================================================================================================
def simple_gen():
    yield 10
    yield 20
    yield 30

# Create a generator object
gen = simple_gen()

# Use the generator in a for loop
for value in gen:
    print(value)

 Output:
10
20
30
============================================================================================================================================================================
Non-Local Variables in Nested Functions
Each variable has a scope, which refers to the part of the code where we can find and access a variable whenever required. We can access non-local variables only within their scope and not outside it. 

Example
def counter():
    count = 0  # `count` is a non-local variable for `increment()`
    def increment():
        nonlocal count
        count += 1
        return count
    return increment

# Create a counter function instance
my_counter = counter()

# Use the counter function
print(my_counter())  # Output: 1
print(my_counter())  # Output: 2
print(my_counter())  # Output: 3

Output:
1
2
3
========================================================================================================================================================================================================
Example 
def create_greeting(template):
    def greet(name):
        return template.format(name=name)
    return greet

# Create specific greeting functions
formal_greeting = create_greeting("Hello, {name}. How do you do?")
casual_greeting = create_greeting("Hey {name}! What's up?")

# Use the greeting functions
print(formal_greeting("Raman"))  
print(casual_greeting("Suman"))  

Output:
Hello, Raman. How do you do?
Hey Suman! What's up?
=======================================================================================================================================================================================================
#@Property in python
class Temperature:
    def __init__(self, celsius):
        self._celsius = celsius

    @property
    def celsius(self):
        """Getter for the celsius property."""
        return self._celsius

    @celsius.setter
    def celsius(self, value):
        """Setter for the celsius property."""
        if value < -273.15:
            raise ValueError("Temperature cannot be below -273.15 Celsius")
        self._celsius = value

    @celsius.deleter
    def celsius(self):
        """Deleter for the celsius property."""
        del self._celsius

    @property
    def fahrenheit(self):
        """Getter for the fahrenheit property."""
        return self._celsius * 9/5 + 32

# Usage
temp = Temperature(25)
print(temp.celsius)         # Output: 25
print(temp.fahrenheit)      # Output: 77.0

temp.celsius = 30           # Set new temperature
print(temp.fahrenheit)      # Output: 86.0

del temp.celsius            # Delete the celsius attribute
# print(temp.celsius)       # This would raise an AttributeError because the attribute has been deleted
====================================================================================================================================================================
Using property() Method 
Example 
class Temperature:
    def __init__(self, celsius):
        self._celsius = celsius

    def get_celsius(self):
        """Getter for the celsius property."""
        return self._celsius

    def set_celsius(self, value):
        """Setter for the celsius property."""
        if value < -273.15:
            raise ValueError("Temperature cannot be below -273.15 Celsius")
        self._celsius = value

    def del_celsius(self):
        """Deleter for the celsius property."""
        del self._celsius

    def get_fahrenheit(self):
        """Getter for the fahrenheit property."""
        return self._celsius * 9/5 + 32

    # Define the property
    celsius = property(get_celsius, set_celsius, del_celsius)
    fahrenheit = property(get_fahrenheit)

# Usage
temp = Temperature(25)
print(temp.celsius)         # Output: 25
print(temp.fahrenheit)      # Output: 77.0

temp.celsius = 30           # Set new temperature
print(temp.fahrenheit)      # Output: 86.0

del temp.celsius            # Delete the celsius attribute
# print(temp.celsius)       # This would raise an AttributeError because the attribute has been deleted

Output:
25
77.0
86.0
===========================================================================================================================================================================================
class Square:
    def __init__(self, side_length):
        self._side_length = side_length

    @property
    def area(self):
        """Calculate the area of the square."""
        return self._side_length ** 2

    @property
    def side_length(self):
        """Getter for side_length."""
        return self._side_length

    @side_length.setter
    def side_length(self, value):
        """Setter for side_length."""
        if value <= 0:
            raise ValueError("Side length must be positive.")
        self._side_length = value

# Usage
sq = Square(4)
print(sq.area)           # Output: 16
print(sq.side_length)   # Output: 4

sq.side_length = 5       # Set new side length
print(sq.area)           # Output: 25

Output:
16
4
25
=====================================================================================================================
#Python Attribute vs Property
class BankAccount:
    # Class attribute
    interest_rate = 0.03
    def __init__(self, balance):
        # Instance attribute
        self.balance = balance
    def apply_interest(self):
        self.balance += self.balance * BankAccount.interest_rate

# Create instances
acc1 = BankAccount(1000)
acc2 = BankAccount(2000)

# Apply interest to both accounts
acc1.apply_interest()
acc2.apply_interest()
print(acc1.balance)  # Output: 1030.0
print(acc2.balance)  # Output: 2060.0

Output:
1030.0
2060.0
=====================================================================================================================
Python property()
It returns the object of the property class. The following example shows the use property() function. 

Example 
class Circle:
    def __init__(self, radius):
        self._radius = radius

    def get_radius(self):
        return self._radius

    def set_radius(self, value):
        if value <= 0:
            raise ValueError("Radius must be positive.")
        self._radius = value

    def del_radius(self):
        del self._radius

    def get_area(self):
        return 3.14 * self._radius ** 2

    # Define properties using property()
    radius = property(get_radius, set_radius, del_radius)
    area = property(get_area)

# Usage
circle = Circle(5)
print(circle.radius)  # Output: 5
print(circle.area)    # Output: 78.5

circle.radius = 10    # Set new radius
print(circle.area)    # Output: 314.0

Output:
5
78.5
314.0
=======================================================================================================================================================
#@property-name.setter

Example 
class Temperature:
    def __init__(self, celsius):
        self._celsius = celsius

    @property
    def celsius(self):
        """Getter for the celsius property."""
        return self._celsius

    @celsius.setter
    def celsius(self, value):
        """Setter for the celsius property."""
        if value < -273.15:
            raise ValueError("Temperature cannot be below -273.15 Celsius")
        self._celsius = value

# Usage
temp = Temperature(25)
print(temp.celsius)  # Output: 25

temp.celsius = 30    # Set new temperature
print(temp.celsius)  # Output: 30

Output:
25
30
==================================================================================================================================================================
#@property-name.deleter
Example  
class Item:
    def __init__(self, name):
        self._name = name
    @property
    def name(self):
        """Getter for the name property."""
        return self._name

    @name.deleter
    def name(self):
        """Deleter for the name property."""
        del self._name

# Usage
item = Item("Widget")
print(item.name)  # Output: Widget
del item.name     # Delete the name property

Output:
Widget

============================================================================================================================================================================
#@property-name.deleter

#Here is an example demonstrating how to use the deleter decorator method to delete the property of the class.

Example  
class Item:
    def __init__(self, name):
        self._name = name
    @property
    def name(self):
        """Getter for the name property."""
        return self._name

    @name.deleter
    def name(self):
        """Deleter for the name property."""
        del self._name

# Usage
item = Item("Widget")
print(item.name)  # Output: Widget
del item.name     # Delete the name property

Output:
Widget
================================================================================================================================================================================================
#Using Getters and Setters
class Square:
    def __init__(self, side_length):
        self._side_length = side_length

    @property
    def side_length(self):
        """Getter for side_length."""
        return self._side_length

    @side_length.setter
    def side_length(self, value):
        """Setter for side_length."""
        if value <= 0:
            raise ValueError("Side length must be positive.")
        self._side_length = value

    @property
    def area(self):
        """Compute the area of the square."""
        return self._side_length ** 2

# Usage
square = Square(4)
print(square.side_length)
print(square.area)      

square.side_length = 5  
print(square.area)      

Output:
4
16
25
======================================================================================================================================
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)

    def __str__(self):
        return f"({self.x}, {self.y})"

p1 = Point(2, 3)
p2 = Point(4, 5)
p3 = p1 + p2

print(p3)  # Output: (6, 8)

Output:
  # Output: (6, 8)
========================================================================================================================================
class ComplexNumber:
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag

    # Overloading the binary + operator
    def __add__(self, other):
        real_part = self.real + other.real
        imag_part = self.imag + other.imag
        return ComplexNumber(real_part, imag_part)

    def __str__(self):
        return f"{self.real} + {self.imag}i"

# Creating two complex number objects
c1 = ComplexNumber(3, 2)
c2 = ComplexNumber(1, 7)

# Adding two complex numbers using the overloaded + operator
c3 = c1 + c2

print(c3)  # Output: 4 + 9i

Output:
4 + 9i
==============================================================================================================================================
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __mul__(self, scalar):
        return Vector(self.x * scalar, self.y * scalar)

    def __rmul__(self, scalar):
        return self.__mul__(scalar)

    def __str__(self):
        return f"Vector({self.x}, {self.y})"

# Creating a Vector object
v = Vector(2, 3)

# Multiplying the vector by a scalar
v2 = v * 4  # Using __mul__
v3 = 3 * v  # Using __rmul__

# Displaying the results
print(v2)  # Output: Vector(8, 12)
print(v3)  # Output: Vector(6, 9)

Output:
Vector(8, 12)
Vector(6, 9)
===================================================================================================================================================
Example- String Representation
class Book:
    def __init__(self, title, author, price):
        self.title = title
        self.author = author
        self.price = price

    def __str__(self):
        # Defines a readable string representation for the end-user
        return f"'{self.title}' by {self.author}, priced at ₹{self.price}"

    def __repr__(self):
        # Defines a more detailed string representation for debugging
        return f"Book(title='{self.title}', author='{self.author}', price={self.price})"

# Creating an instance of the Book class
book = Book("The Guide", "R.K. Narayan", 250)

# Using the __str__ method
print(str(book))  # Output: 'The Guide' by R.K. Narayan, priced at ₹250

# Using the __repr__ method
print(repr(book))  # Output: Book(title='The Guide', author='R.K. Narayan', price=250)

Output:
'The Guide' by R.K. Narayan, priced at ₹250
Book(title='The Guide', author='R.K. Narayan', price=250)
=============================================================================================================================================================
class Rectangle:
    def __init__(self, length, width):
        self.length = length
        self.width = width
        self.area = length * width

    def __lt__(self, other):
        return self.area < other.area

    def __le__(self, other):
        return self.area <= other.area

    def __gt__(self, other):
        return self.area > other.area

    def __ge__(self, other):
        return self.area >= other.area

    def __eq__(self, other):
        return self.area == other.area

    def __ne__(self, other):
        return self.area != other.area

    def __str__(self):
        return f"Rectangle({self.length} x {self.width})"

# Creating two rectangle objects
rect1 = Rectangle(4, 5)
rect2 = Rectangle(3, 7)

# Comparing the rectangles using overloaded comparison operators
print(rect1 > rect2)   # Output: False
print(rect1 < rect2)   # Output: True
print(rect1 >= rect2)  # Output: False
print(rect1 <= rect2)  # Output: True
print(rect1 == rect2)  # Output: False
print(rect1 != rect2)  # Output: True

Output:
False
True
False
True
False
True
==========================================================================================================
class Student:
    def __init__(self, name, grade):
        self.name = name
        self.grade = grade

    def __eq__(self, other):
        """Override the equality operator (==)"""
        if isinstance(other, Student):
            return self.grade == other.grade
        return False

    def __lt__(self, other):
        """Override the less-than operator (<)"""
        if isinstance(other, Student):
            return self.grade < other.grade
        return False

    def __repr__(self):
        return f'Student(name={self.name}, grade={self.grade})'

# Create Student objects
student1 = Student("Alice", 90)
student2 = Student("Bob", 85)
student3 = Student("Charlie", 90)

# Compare students
print(student1 == student2)  # Output: False
print(student1 == student3)  # Output: True
print(student2 < student1)   # Output: True
print(student1 < student3)   # Output: False

Output:
False
True
True
False

