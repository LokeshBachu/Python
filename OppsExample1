# Base class
class Animal:
    def speak(self):
        return "Animal makes a sound"
# Derived class
class Dog(Animal):
    def speak(self):
        return "Woof!"

# Create an instance of the derived class
my_dog = Dog()

# Call the method from the derived class
print(my_dog.speak())  # Output: Woof!
================================================================================================================================
#Multiple inheritence
# Base class 1
class Person:
    def __init__(self, name):
        self.name = name
    def greet(self):
        return f"Hello, my name is {self.name}."
# Base class 2
class Employee:
    def __init__(self, employee_id):
        self.employee_id = employee_id
    def get_id(self):
        return f"My employee ID is {self.employee_id}."
# Derived class inheriting from both Person and Employee
class Manager(Person, Employee):
    def __init__(self, name, employee_id, department):
        Person.__init__(self, name)  # Initialize Person part
        Employee.__init__(self, employee_id)  # Initialize Employee part
        self.department = department
    def show_details(self):
        return f"{self.greet()} {self.get_id()} I manage the {self.department} department."

# Create an instance of the derived class
manager = Manager("Alice", "E12345", "Sales")

# Call methods from base classes and derived class
print(manager.greet())         # Output: Hello, my name is Alice.
print(manager.get_id())        # Output: My employee ID is E12345.
print(manager.show_details())  # Output: Hello, my name is Alice. My employee ID is E12345. I manage the Sales department.
=================================================================================================================================
#Multilevel Inheritence

# Base class
class Animal:
    def __init__(self, species):
        self.species = species
    def eat(self):
        return f"{self.species} is eating."

# Derived class from Animal
class Mammal(Animal):
    def __init__(self, species, fur_color):
        super().__init__(species)  # Initialize the base class (Animal)
        self.fur_color = fur_color
    def breathe(self):
        return f"{self.species} breathes air."

# Further derived class from Mammal
class Dog(Mammal):
    def __init__(self, species, fur_color, name):
        super().__init__(species, fur_color)  # Initialize the base class (Mammal)
        self.name = name
    def bark(self):
        return f"{self.name} says Woof!"

# Create an instance of the Dog class
my_dog = Dog("Dog", "Brown", "Buddy")

# Call methods from all levels of the inheritance chain
print(my_dog.eat())        # Output: Dog is eating.
print(my_dog.breathe())    # Output: Dog breathes air.
print(my_dog.bark())       # Output: Buddy says Woof!

===============================================================================================================================
#Heirarchical Inheritence

# Base class
class Animal:
    def __init__(self, species):
        self.species = species
    def speak(self):
        return f"{self.species} makes a sound."

# Derived class 1
class Dog(Animal):
    def __init__(self, name):
        super().__init__("Dog")  # Initialize the base class with species
        self.name = name
    def bark(self):
        return f"{self.name} says Woof!"

# Derived class 2
class Cat(Animal):
    def __init__(self, name):
        super().__init__("Cat")  # Initialize the base class with species
        self.name = name
    def meow(self):
        return f"{self.name} says Meow!"
# Creating instances of the derived classes
dog = Dog("Buddy")
cat = Cat("Whiskers")
# Calling methods from base class and derived classes
print(dog.speak())  # Output: Dog makes a sound.
print(dog.bark())   # Output: Buddy says Woof!
print(cat.speak())  # Output: Cat makes a sound.
print(cat.meow())   # Output: Whiskers says Meow!
================================================================================================================================
#Public access modifier
class MyClass:
    def __init__(self, value):
        self.value = value  # Public attribute
    def show_value(self):  # Public method
        print(self.value)
# Usage
obj = MyClass(10)
obj.show_value()  # Accessing public method
print(obj.value)  # Accessing public attribute

Output:
10
10

===================================================================================================================================
#private access modifier
class MyClass:
    def __init__(self, value):
        self.__value = value  # Private attribute
    def __show_value(self):  # Private method
        print(self.__value)
    def public_method(self):  # Public method
        self.__show_value()  # Accessing private method within the class

# Usage
obj = MyClass(10)
# obj.__show_value()  # This would raise an AttributeError
# print(obj.__value)  # This would raise an AttributeError
obj.public_method()  # Accesses private method through a public method

Output:
10
================================================================================================================================
#Protected access modifier
lass BaseClass:
    def __init__(self, value):
        self._value = value  # Protected attribute
    def _show_value(self):  # Protected method
        print(self._value)

class SubClass(BaseClass):
    def display(self):
        self._show_value()  # Accessing protected method from the subclass

# Usage
obj = SubClass(10)
obj.display()  # Accessing protected method via public method in subclass
print(obj._value)  # Accessing protected attribute directly (not recommended)

Output:
10
10

======================================================================================================================================
#Polymorphism in Python Example
class Shape:
    def area(self):
        raise NotImplementedError("Subclasses should implement this!")
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    def area(self):
        return self.width * self.height
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    def area(self):
        import math
        return math.pi * self.radius ** 2
def print_area(shape):
    print(f"The area is: {shape.area()}")

# Usage
rectangle = Rectangle(5, 10)
circle = Circle(3)
print_area(rectangle)  # The area is: 50
print_area(circle)     # The area is: 28.274333882308138

Output:
The area is: 50
The area is: 28.274333882308138
======================================================================================================================================
#Example:Polymorphiem with class methods
class Dog:
    def speak(self):
        print("Woof!")
class Cat:
    def speak(self):
        print("Meow!")
class Bird:
    def speak(self):
        print("Chirp!")

# Tuple of objects
animals = (Dog(), Cat(), Bird())

# Call speak method on each object
for animal in animals:
    animal.speak()

Output:
Woof!
Meow!
Chirp!
=======================================================================================================================================
#Polymorphisum with inheritence
class Animal:
    def make_sound(self):
        print("Some generic sound")
class Dog(Animal):
    def make_sound(self):
        print("Woof!")
class Cat(Animal):
    def make_sound(self):
        print("Meow!")
# Create instances
animals = [Dog(), Cat()]
# Call make_sound method on each object
for animal in animals:
    animal.make_sound()

Output:
Woof!
Meow!
===============================================================================================================================================
#Polymorphisum with functions and objects
def process_object(obj):
    obj.action()
class Printer:
    def action(self):
        print("Printing...")
class Scanner:
    def action(self):
        print("Scanning...")

# Create instances
printer = Printer()
scanner = Scanner()

# Use the same function with different objects
process_object(printer)  # Printing...
process_object(scanner)  # Scanning...

Output:
Printing...
Scanning...
=========================================================================================================================================================
#Python Constructor Example
class Dog:
    def __init__(self, name, breed):
        self.name = name
        self.breed = breed

# Creating an instance of the Dog class
my_dog = Dog("Buddy", "Golden Retriever")

# Accessing attributes
print(my_dog.name)  # Output: Buddy
print(my_dog.breed)  # Output: Golden Retriever

Output:
Buddy
Golden Retriever
=============================================================================================================================================================
class Car:
    def __init__(self, make, model, year):
        self.make = make
        self.model = model
        self.year = year
    def display_info(self):
        print(f"{self.year} {self.make} {self.model}")

# Create an instance of the Car class
my_car = Car("Toyota", "Corolla", 2020)

# Display the car's information
my_car.display_info()

Output:
2020 Toyota Corolla

===================================================================================================================================================================
#Parameterized Constructor in Python Example 
class Person:
    def __init__(self, name, age, city):
        self.name = name
        self.age = age
        self.city = city
    def introduce(self):
        print(f"Hello, my name is {self.name}. I'm {self.age} years old and I live in {self.city}.")

# Creating instances of the Person class with Indian names and cities
person1 = Person("Amit", 28, "Mumbai")
person2 = Person("Priya", 24, "Bengaluru")

# Introducing the persons
person1.introduce()  # Output: Hello, my name is Amit. I'm 28 years old and I live in Mumbai.
person2.introduce()  # Output: Hello, my name is Priya. I'm 24 years old and I live in Bengaluru.

Output:
Hello, my name is Amit. I'm 28 years old and I live in Mumbai.
Hello, my name is Priya. I'm 24 years old and I live in Bengaluru.
============================================================================================================================================================================
#Non parametarized constructor
class Person:
    def __init__(self):
        self.name = "John Doe"
        self.age = 30
    def display_info(self):
        print(f"Name: {self.name}, Age: {self.age}")

# Create an instance of the Person class using the non-parameterized constructor
person = Person()

# Display the person's information
person.display_info()

Output:
Name: John Doe, Age: 30
=====================================================================================================================================================================================
#Mutiple constructors in single python class.
class Rectangle:
    def __init__(self, width=0, height=0):
        if width and height:
            self.width = width
            self.height = height
        elif width:  # Single argument used as a square's side
            self.width = width
            self.height = width
        else:  # No arguments
            self.width = 0
            self.height = 0
    def area(self):
        return self.width * self.height
    def display_info(self):
        print(f"Width: {self.width}, Height: {self.height}, Area: {self.area()}")

# Create instances using different "constructors"
rect1 = Rectangle(10, 20)  # Two arguments
rect2 = Rectangle(10)      # One argument (treated as square)
rect3 = Rectangle()        # No arguments

# Display the rectangles' information
rect1.display_info()  # Width: 10, Height: 20, Area: 200
rect2.display_info()  # Width: 10, Height: 10, Area: 100
rect3.display_info()  # Width: 0, Height: 0, Area: 0

Output:
Width: 10, Height: 20, Area: 200
Width: 10, Height: 10, Area: 100
Width: 0, Height: 0, Area: 0
===============================================================================================================================================================================================
#Method Overriding in Python Example
class Animal:
    def sound(self):
        return "Some generic animal sound"
class Dog(Animal):
    def sound(self):
        return "Bark"
class Cat(Animal):
    def sound(self):
        return "Meow"

# Creating objects of each class
generic_animal = Animal()
dog = Dog()
cat = Cat()

# Calling the sound method on each object
print(generic_animal.sound())  # Output: Some generic animal sound
print(dog.sound())             # Output: Bark
print(cat.sound())             # Output: Meow

Output:
Some generic animal sound
Bark
Meow
===============================================================================================================================================================================================
#Method resolution order
lass A:
    def who_am_i(self):
        return "I am A"
class B(A):
    def who_am_i(self):
        return "I am B"
class C(A):
    def who_am_i(self):
        return "I am C"
class D(B, C):
    pass

# Creating an object of class D
d = D()

# Method resolution order
print(d.who_am_i())  # Output: I am B

# Display the Method Resolution Order
print(D.mro())

Output:
I am B
[<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]

====================================================================================================================================================================================================
#Method overriding with multiple and multilevel inheritence
class B:
    def show(self):
        return "Show method from class B"
class C:
    def show(self):
        return "Show method from class C"
class D(B, C):
    def show(self):
        return "Show method from class D"

# Creating an object of class D
d = D()

# Calling the show method on the object of class D
print(d.show())  # Output: Show method from class D

# Displaying the MRO to see the order of inheritance

Output:
Show method from class D
[<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class 'object'>]
=============================================================================================================================================================================================================

#Overriding in multilevel inheritence

class Parent:
    def greet(self):
        return "Hello from Parent"

class Child(Parent):
    def greet(self):
        parent_message = Parent.greet(self)
        return f"{parent_message} and Hello from Child"

# Creating an object of the Child class
c = Child()

# Calling the greet method on the Child object
print(c.greet())  # Output: Hello from Parent and Hello from Child

Output:
Hello from Parent and Hello from Child

=====================================================================================================================================================================================================================
#Super()
class Parent:
    def greet(self):
        return "Hello from Parent"

class Child(Parent):
    def greet(self):
        parent_message = super().greet()
        return f"{parent_message} and Hello from Child"

# Creating an object of the Child class
c = Child()

# Calling the greet method on the Child object
print(c.greet())

 Output:
Hello from Parent and Hello from Child
=============================================================================================================================================================================================================================
#Basic data absraction
from abc import ABC, abstractmethod
class Animal(ABC):
    @abstractmethod
    def sound(self):
        pass

class Dog(Animal):
    def sound(self):
        return "Bark"

# Creating an object of the Dog class
dog = Dog()
print(dog.sound())  # Output: Bark

Output:
Bark
==================================================================================================================================================================================================================================
from abc import ABC, abstractmethod
class Car(ABC):
    @abstractmethod
    def start_engine(self):
        pass
    @abstractmethod
    def stop_engine(self):
        pass
class Kia(Car):
    def start_engine(self):
        return "Kia engine started"
    def stop_engine(self):
        return "Kia engine stopped"
class Honda(Car):
    def start_engine(self):
        return "Honda engine started"
    def stop_engine(self):
        return "Honda engine stopped"

# Creating objects of the derived classes
kia = Kia()
honda = Honda()

# Calling the methods on the objects
print(kia.start_engine())  # Output: Kia engine started
print(kia.stop_engine())   # Output: Kia engine stopped
print(honda.start_engine())  # Output: Honda engine started
print(honda.stop_engine())   # Output: Honda engine stopped

Output:
Kia engine started
Kia engine stopped
Honda engine started
Honda engine stopped
===================================================================================================================================================================================
#Concrete method in abstract base class
from abc import ABC, abstractmethod
class MyABC(ABC):
    @abstractmethod
    def abstract_method1(self):
        """Method that must be implemented in subclass."""
        pass
    @abstractmethod
    def abstract_method2(self):
        """Another method that must be implemented in subclass."""
        pass
class ConcreteClass(MyABC):
    def abstract_method1(self):
        return "Implementation of abstract_method1"
    def abstract_method2(self):
        return "Implementation of abstract_method2"

# Creating an object of ConcreteClass
concrete = ConcreteClass()

# Calling the implemented methods
print(concrete.abstract_method1())  # Output: Implementation of abstract_method1
print(concrete.abstract_method2())  # Output: Implementation of abstract_method2

Output:
Implementation of abstract_method1
Implementation of abstract_method2
=====================================================================================================================================================================================
create an abstract base class and abstract method?
Example 
from abc import ABC, abstractmethod
class Shape(ABC):
    @abstractmethod
    def area(self):
        pass
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    def area(self):
        return 3.14 * self.radius ** 2

# Creating an object of Circle
circle = Circle(5)
print(circle.area())  # Output: 78.5

Output:
78.5
=======================================================================================================================================================================================

